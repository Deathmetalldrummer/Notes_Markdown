# ChangeDetectionStrategy

[Статья](https://www.infiniswiss.com/blog/angular/2020/10/23/change-detection-angular/)

В Angular для обнаружения изменений используется библиотека [Zone](./Zone.js.md).

В Angular есть две стратегии обнаружения изменений — «Default» и «onPush»

##### Плюсы и минусы

+Оптимизация

-Усложняет жизнь, заставляет самому отслеживать асинхронные изменения в компоненте

### **ChangeDetectionStrategy.Default**

Каждый раз, когда что-то меняется в нашем приложении, в результате различных пользовательских событий, таймеров, XHR, промисов и т.д., обнаружение изменений будет запускаться по всем компонентам

Этот цикл называется грязной проверкой (dirty checking). Суть проверки заключается в том, что Angular сравнивает новые значения со старыми и обновляет представление если они не равны.

Теперь представьте большое приложение с огромным количеством компонентов и множеством условий. Если мы позволим Angular, каждый раз, когда запускается цикл обнаружения изменений, проверять каждое из этих условий, это негативно скажется на производительности.

```ts
@Component({
  selector: 'hello',
  template: `
    <h1>Hello {{name}}!</h1>
    {{runChangeDetection}}
  `
})
export class HelloComponent {
  @Input() name: string;
  get runChangeDetection() {
    console.log('Checking the view');
    return true;
  }
}
```

```ts
@Component({
  selector: 'app-root',
  template: `
    <hello></hello>
    <button (click)="onClick()">Trigger change detection</button>
  `
})
export class AppComponent {
  onClick() {}
}
```



### OnPush

Компонент теперь зависит только от **@inputs()** параметров, и будет проверятся только при таких условиях:

1. **Изменилась ссылка input параметра**

   Установив OnPush стратегию, мы как бы подписываем договор с Angular, который обязывает нас работать с иммутабельными объектами (или наблюдаемыми (observables).

   Преимущество работы с иммутабельными данными в контексте обнаружения изменений в том, что Angular выполняет простую проверку по ссылке, чтобы решить, следует ли проверять представление. Это намного быстрее чем глубокое сравнение объектов.

   Числа, булевые, строки, null и undefined это примитивные типы. Все примитивные типы передаются по значению. Объекты, массивы, и функции передаются по ссылке.

   Чтобы запустить механизм обнаружения изменений, мы должны изменить саму ссылку на объект.

2. **Событие внутри компонента или его потомках**

   Триггером запуска механизма обнаружения изменений будут только события DOM компонента и его потомков, а все асинхронные события нет.	

3. **Ручной запуск обнаружения изменений**

   Angular предоставляет нам три метода для самостоятельного запуска механизма обнаружения изменений и мы можем вызывать их в нужных нам местах.

   1. **detectChanges()** говорит Angular запустить обнаружение изменений в компоненте и его потомках.

      ```ts
      constructor(private cdr: ChangeDetectorRef) {}
      this.cdr.detectChanges();
      ```

   2. **ApplicationRef.tick()** говорит Angular запустить обнаружение изменений во всем приложении.

      ```ts
      constructor (private appRef: ApplicationRef) {}
      this.appRef.tick();
      ```

   3. **markForCheck()**, который **не** триггерит запуск обнаружения изменений. Вместо этого он помечает компонент и всех его родителей, что они должны быть проверены в текущем или следующем цикле обнаружения изменений.

      ```ts
      constructor(private cdr: ChangeDetectorRef) {}
      this.cdr.markForCheck();
      ```

   
   Кроме того, в классе **ChangeDetectorRef** есть метод `detach`, который позволяет выключить проверку изменений и метод `reattach`, позволяющий включить проверку после ее выключения.

#### Аngular Async пайп

async пайп отмечает компонент как необходимый к проверке.Angular вызывает **markForCheck()**, поэтому представление обновляется даже когда ссылки не изменились.

#### OnPush и шаблонные переменные

Пока не понятно

#### === onPush++

 Чем больше компонентов с OnPush стратегией мы имеем, тем меньше проверок будет выполнять сам Angular


https://habr.com/ru/companies/tbank/articles/581378/
