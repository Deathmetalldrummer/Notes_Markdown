# Основные принципы программирования: императивное и декларативное программирование

[Переводы](https://tproger.ru/category/translations/), 26 января 2017 в 20:41 61 889

![Обложка: Основные принципы программирования: императивное и декларативное программирование](https://tproger.ru/s3/uploads/2017/01/impdecmini.png)



*Рассказывает [Тайлер МакГиннис](https://developers.google.com/experts/people/tyler-mcginnis), Google Developer Expert* 

------

Вы наверняка слышали о таких понятиях, как императивное и декларативное программирование, и скорее всего гуглили определения. И поэтому вы наверняка видели что-то подобное: «Императивное программирование — это описание того, **как** ты делаешь что-то, а декларативное — того, **что** ты делаешь. Это объяснение отлично подходит тем, кто уже разобрался в этом вопросе — но не новичкам. 

Самым сложным является тот факт, что разница между декларативным и императивным подходами часто понятна интуитивно, но её сложно задать определением. Я общался со многими программистами и пришёл к заключению, что лучшее объяснение — это сочетание метафор и примеров кода. Итак, начнём.

Допустим, вы поняли, что слишком много времени уделяли работе, и решили пригласить свою половинку на свидание. Вы пришли в ресторан, подошли к администратору и сказали…

**Императивный подход (как)**: Я вижу, что тот угловой столик свободен. Мы пойдём туда и сядем там.

**Декларативный подход (что)**: Столик для двоих, пожалуйста.

Императивный подход означает то, как вы займёте место. Вы должны перечислить все шаги этого процесса. Декларативный же подход заявляет, что вам нужен столик на двоих.

Больше метафор!

Я задам вам вопрос и хочу, чтобы вы придумали и императивный, и декларативный подход.

> «Я у Ашана. Как мне пройти до твоего дома?»

------

Императивный ответ:

> «Пройди через северный выход парковки и поверни налево. Сядь на автобус 678 и выйди на остановке «Улица Победы». Поверни направо, как если бы ты шёл в Икею. Иди прямо и поверни направо у первого светофора. На следующем светофоре поверни налево. Номер моего дома — 134.»

Декларативный ответ:

> Мой адрес: Энск, улица Победы, дом 134.

Неважно, как я попаду к твоему дому, важно, на какой машине я приеду. У неё будет или императивная механическая КПП, или декларативная автоматическая КПП. Достаточно метафор?

Прежде чем мы обратимся к коду, важно понять, что многие декларативные подходы имеют определённый слой императивных абстракций. Вернёмся к нашим примерам. Декларативное обращение к сотруднику ресторана подразумевает, что он знает все императивные шаги по предоставлению вам столика. Знание адреса подразумевает, что у вас есть GPS-навигатор, который знает императивные шаги по составлению маршрута. У автомобиля с автоматической КПП есть определённый слой абстракций над переключением передач.

Итак, я повторюсь: многие (если не все) декларативные подходы имеют слой неких императивных абстракций.

Теперь мы перейдём от приятных метафор к реальному коду. Сперва посмотрим, какие языки являются декларативными, а какие — императивными:

- Императивные: C, C++, Java.
- Декларативные: SQL, HTML.
- Смешанные (могут быть таковыми): JavaScript, C#, Python.

Вот типичные примеры на SQL и HTML:

```sql
SELECT * FROM Users WHERE Country=’Mexico’;
<article>
  <header>
    <h1>Declarative Programming</h1>
    <p>Sprinkle Declarative in your verbiage to sound smart</p>
  </header>
</article>
```

Достаточно взглянуть на них, чтобы понять, что происходит. Они декларативны, заявляя, *что* должно быть сделано, а не *как*. Вы описываете желаемый результат, не углубляясь в инструкции. Неважно, как будут выбраны пользователи из Мексики. Неважно, как браузер распарсит ваш `article`. Важно, что вы получите мексиканских пользователей и новый `header` и `paragraph` на сайте.

Пока неплохо. Давайте рассмотрим примеры на JavaScript.

Представьте, что вы на собеседовании. Откройте консоль и ответьте на следующие вопросы.

1. Напишите функцию, называющуюся `double`, которая принимает массив чисел и возвращает новый массив, каждый элемент которого в два раза больше входного: `double([1,2,3]) -> [2,4,6]`.
2. Напишите функцию, называющуюся `add`, которая принимает массив и возвращает сумму всех его элементов: `add([1,2,3]) -> 6`.
3. Используя jQuery (или чистый JavaScript), добавьте обработчик события `click` к элементу с `id`, равным `btn`. По нажатию переключите класс `highlight` и смените текст на `Add Highlight` или `Remove Highlight`, в зависимости от текущего состояния элемента.

------

Давайте взглянем на самые распространённые подходы к решению этих задач, которые являются императивными.

```javascript
function double (arr) {
  let results = []
  for (let i = 0; i < arr.length; i++){
    results.push(arr[i] * 2)
  }
  return results
}
function add (arr) {
  let result = 0
  for (let i = 0; i < arr.length; i++){
    result += arr[i]
  }
  return result
}
$("#btn").click(function() {
  $(this).toggleClass("highlight")
  $(this).text() === 'Add Highlight'
    ? $(this).text('Remove Highlight')
    : $(this).text('Add Highlight')
})
```

Разобравшись, что общего у этих императивных примеров, мы поймём, что именно делает их императивными.

1. Очевидно, что все они описывают, *как* решить проблему: мы явно указываем все шаги.
2. Это уже не так очевидно для тех, кто не привык думать декларативно, или даже функционально. В каждом примере происходит изменение какого-либо состояния. В первых двух примерах происходило изменение переменной `results`, а в третьей состояние было в самой DOM – и его мы тоже изменяли.
3. Это уже субъективно, но я считаю, что код выше нечитаем. Я не могу с первого взгляда понять, что происходит — вместо этого мне приходится читать код построчно.

А теперь взглянем на декларативные примеры. Их цель — решить все проблемы, описанные выше. Поэтому каждый пример должен описывать, что происходит, быть неизменяемым и читаемым.

```javascript
function double (arr) {
  return arr.map((item) => item * 2)
}
function add (arr) {
  return arr.reduce((prev, current) => prev + current, 0)
}
<Btn
  onToggleHighlight={this.handleToggleHighlight}
  highlight={this.state.highlight}>
    {this.state.buttonText}
</Btn>
```

Гораздо лучше ?

Заметьте, что в первых двух примерах я использовал встроенные методы JavaScript, `map` и `reduce`. Как видите, декларативные решения вновь оказались абстракциями над императивными реализациями. Но нас не интересует, как реализованы эти методы. Мы также не изменяем состояния, да и читается этот код лучше.

Ну а третий? В нём я немного схитрил, использовав React — но обратите внимание, что все три императивные ошибки исправлены. React замечателен тем, что в нём вы можете создавать декларативные пользовательские интерфейсы. Смотря на компонент Btn, сразу понятно, как будет выглядеть интерфейс. Кроме того, состояния «живут» не в DOM, а в самом React-компоненте.

Ещё одним преимуществом является то, что декларативный код является контекстно-независимым. Это значит, что его можно использовать в любой программе без изменений.